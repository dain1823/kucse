$date
	Wed Jun 03 00:48:02 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TOP $end
$var wire 4 ! sum [3:0] $end
$var wire 1 " overflow $end
$var wire 1 # carry $end
$var reg 4 $ a [3:0] $end
$var reg 4 % b [3:0] $end
$var reg 32 & i [31:0] $end
$var reg 1 ' sub_not_add $end
$scope module CLA $end
$var wire 4 ( A [3:0] $end
$var wire 4 ) B [3:0] $end
$var wire 1 ' M $end
$var wire 1 " V $end
$var wire 5 * carry [4:0] $end
$var wire 4 + b [3:0] $end
$var wire 4 , S [3:0] $end
$var wire 4 - P [3:0] $end
$var wire 4 . G [3:0] $end
$var wire 1 # C $end
$scope begin adc_ha[0] $end
$scope module HA $end
$var wire 1 / c $end
$var wire 1 0 s $end
$var wire 1 1 x $end
$var wire 1 2 y $end
$upscope $end
$upscope $end
$scope begin adc_ha[1] $end
$scope module HA $end
$var wire 1 3 c $end
$var wire 1 4 s $end
$var wire 1 5 x $end
$var wire 1 6 y $end
$upscope $end
$upscope $end
$scope begin adc_ha[2] $end
$scope module HA $end
$var wire 1 7 c $end
$var wire 1 8 s $end
$var wire 1 9 x $end
$var wire 1 : y $end
$upscope $end
$upscope $end
$scope begin adc_ha[3] $end
$scope module HA $end
$var wire 1 ; c $end
$var wire 1 < s $end
$var wire 1 = x $end
$var wire 1 > y $end
$upscope $end
$upscope $end
$scope begin genblk1[0] $end
$upscope $end
$scope begin genblk1[1] $end
$upscope $end
$scope begin genblk1[2] $end
$upscope $end
$scope begin genblk1[3] $end
$upscope $end
$scope begin genblk3[0] $end
$upscope $end
$scope begin genblk3[1] $end
$upscope $end
$scope begin genblk3[2] $end
$upscope $end
$scope begin genblk3[3] $end
$upscope $end
$scope module CLAGEN $end
$var wire 1 ' C0 $end
$var wire 4 ? G [3:0] $end
$var wire 4 @ P [3:0] $end
$var wire 5 A C [4:0] $end
$scope begin genblk1[0] $end
$upscope $end
$scope begin genblk1[1] $end
$upscope $end
$scope begin genblk1[2] $end
$upscope $end
$scope begin genblk1[3] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module fa $end
$var wire 1 B c $end
$var wire 1 C g $end
$var wire 1 D s $end
$var wire 1 E x $end
$var wire 1 F y $end
$var wire 1 G z $end
$var wire 1 H p $end
$var wire 1 I cc $end
$scope module HA1 $end
$var wire 1 I c $end
$var wire 1 H s $end
$var wire 1 E x $end
$var wire 1 F y $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xI
xH
zG
zF
zE
zD
zC
xB
b0 A
b0 @
b0 ?
0>
0=
0<
0;
0:
09
08
07
06
05
04
03
02
01
00
0/
b0 .
b0 -
b0 ,
b0 +
b0 *
b0 )
b0 (
0'
b0 &
b0 %
b0 $
0#
0"
b0 !
$end
#5
1#
0"
b11100 *
b11100 A
b10 .
b10 ?
13
b1 !
b1 ,
16
b10 +
10
04
18
b1101 -
b1101 @
1<
11
15
19
1=
b1 &
b10 %
b10 )
b1111 $
b1111 (
#10
0"
0#
14
b0 .
b0 ?
03
b1111 !
b1111 ,
06
1:
1>
00
18
b1110 -
b1110 @
1<
b1100 +
01
09
0=
b10 &
b1 *
b1 A
1'
b11 %
b11 )
b10 $
b10 (
#15
08
0<
b11 !
b11 ,
16
0:
0>
10
b11 -
b11 @
14
b10 +
11
05
b11 &
b0 *
b0 A
0'
b10 %
b10 )
b1 $
b1 (
#20
0"
04
b101 !
b101 ,
06
00
b100 -
b100 @
18
b0 +
01
19
b100 &
b1 *
b1 A
1'
b1111 %
b1111 )
b100 $
b100 (
#25
0"
1#
1/
b1001 .
b1001 ?
1;
b1000 !
b1000 ,
12
1>
00
14
b110 -
b110 @
0<
b1001 +
11
15
1=
b101 &
b11110 *
b11110 A
0'
b1001 %
b1001 )
b1111 $
b1111 (
#30
08
17
b1100 !
b1100 ,
1:
b11 -
b11 @
10
b1100 .
b1100 ?
0/
b1101 +
01
b110 &
b11111 *
b11111 A
1'
b10 %
b10 )
b1110 $
b1110 (
#35
1"
b111 !
b111 ,
02
10
0/
b111 -
b111 @
18
b1000 .
b1000 ?
07
b1100 +
11
09
b111 &
b10000 *
b10000 A
0'
b1100 %
b1100 )
b1011 $
b1011 (
#40
0"
b1000 !
b1000 ,
16
0:
14
b111 -
b111 @
18
b1000 .
b1000 ?
07
b1010 +
05
19
b1000 &
b11111 *
b11111 A
1'
b101 %
b101 )
b1101 $
b1101 (
#45
0#
1"
b1001 !
b1001 ,
12
1:
0>
10
04
13
18
b101 -
b101 @
0<
b10 .
b10 ?
0;
b111 +
01
15
09
0=
b1001 &
b1100 *
b1100 A
0'
b111 %
b111 )
b10 $
b10 (
#50
0"
1#
14
03
1<
b0 !
b0 ,
02
06
1>
b1111 -
b1111 @
10
b0 .
b0 ?
0/
b1100 +
11
b1010 &
b11111 *
b11111 A
1'
b11 %
b11 )
b11 $
b11 (
#200
